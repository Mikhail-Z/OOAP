package com.company;

import java.util.Arrays;

public class Tasks04_06 {

}


//Задание 4.
//Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми.

//Хорошим кандидатом на то, чтобы модуль был открытым, является потенциальная польза от его расширения.
// Например, сделав модуль "Анализатор логов" открытым, мы даем возможность клиентам самим доопределять изначальнай алгоритм,
// добавляя нужное им поведение (например, отправляя сообщение об ошибке в мессенджер).

//Если модуль делает что-то конкретное и сильного потенциального разнообразия как сделать это действие нет,
// то это кандидат на то, чтобы сделать его закрытым, так как это предупредит попытки его расширить,
// получив корявое решение на выходе.
// Например, модуль занимающийся отправкой документов провайдеру документооборота нужно делать закрытым, так как пользы от его расширения нет, модуль делает вполне определенное действие, и расширять его стандартное поведение нет необходимости.

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//Задание 5.
//Какие из пяти принципов повторного использования модуля поддерживаются в используемом вами языке программирования (в дополнение к классам как базовой синтаксической единице)?

//Из 5 принципов повторного использования модуля в java поддерживаются типы-дженерики. Выглядит это следующим образом:
class Array<T> {
    T[] values;

    Array(T[] values) {
        this.values = values;
    }

    public int length() {
        return this.values.length;
    }

    int getIndex(T value) {
        return Arrays.asList(this.values).indexOf(value);
    }

    T[] range(int start, int end) throws NullPointerException {
        //тяжелое наследие от java без дженериков - возвращается массив Object (приходится приводить руками к типу, который параметризирует)
        return (T[]) Arrays.asList().subList(start, end).toArray();
    }
}

//Модуль (класс в java) объединяет собой набор связанных функций (методов), в которых можно вызывать друг друга (главное не допустить рекурсию!)
//Также несколько модулей (классов) может быть объединено в семейство (пакеты)

//Файл 1
/*
* package java.util;
* public class Arrays {
* ...
* }
* */

//Файл 2
/*
 * package java.util;
 * public class List {
 * ...
 * }
 * */

//

//Возможность выбора кокретной реализации родительского модуля в рантайме (динамически) присутствует в java.
//Для этого переменной типа "родительский модуль" нужно присвоить объект конкретной реализации, которая может меняться в зависимости от условий.
//List<Integer> list = new LinkedList<>();
//Вызывая методы интерфейса будут вызываться методы кокретной реализации.


//Если родительский модуль только задает контракт без реализации (интерфейс), то новый модуль может интегрировать
// поведение нескольких таких модулей, так как разрешено реализовывать несколько интерфейсов.
//Если родительский модуль предствляет собой обычный модуль с реализацией, то интеграция поведения нескольких
// такий модулей невозможна, так как множественное наследование запрещено.

interface IPostgresRepo {
    void connect();
}

interface IDocumentsRepo {
    Integer[] getNewDocumentsIds();
}

class DocumentsRepo implements IPostgresRepo, IDocumentsRepo {

    @Override
    public void connect() {

    }

    @Override
    public Integer[] getNewDocumentsIds() {
        return new Integer[0];
    }
}

//----------------------------------------------------------------------------------------------------------------------

//Задание 6.
//Существуют ли ситуации, когда связи между модулями должны делаться публичными?
//Какие метрики вы бы предложили для количественной оценки принципов организации модулей?
//Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы вы оценили их модульность по этим метрикам?

//Да, связи между модулями должны делаться публичными, когда есть потребность в одном модуле использовать внутри своих функций функциональность друго модуля.
//Например, есть модуль, который содержит бизнес-логику, его функции ссылаются на модуль, содержащий инфраструктурный код (логирование, метрики)

//Для количественной оценки принципов организации модулей можно использовать следующие метрики:
//1) Между модулями нужно соблюдать как можную меньшую связность, т.е. нужно стараться делать модули как можно более
// независимыми, так как иначе каждое изменение в одном модуле приведет к изменению всех завтсязие от него модулей
//2) Функции в одном модуле должны быть сгруппированы по проблематике
//3) Если бы было несколько модулей, то оценить их правильность их организации можно было бы так:
//* Посчитать кол-во модулей, от которых зависит текущий модуль
//* удостовериться, что нет циклических зависимостей
//* удостовериться, что функции модуля, доступные для клиентов (публичные), сгруппированы по проблематике, и функции из разных модулей не дублируют друг друга